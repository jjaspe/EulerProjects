# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

# Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
# Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
# Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
# Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
# Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
# Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...

# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
# The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, 
# square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.


from utils import solve_quadratic

def get_candidates():    
    candidates = []
    # triangle n^2+n-2000 = 0, n^2+n-20000 = 0
    tri_low = solve_quadratic(1,1,-2000)
    tri_high= solve_quadratic(1,1,-20000)
    triangles = [int(n*(n+1)/2) for n in range(int(tri_low[0]+1),int(tri_high[0]))]
    candidates.append(triangles)
    # square n^2 - 1000 = 0, n^2 - 10000 = 0
    squares = [i*i for i in range(int(1000**0.5)+1,int(10000**0.5))]
    candidates.append(squares)
    # pent 3n^2-n-2000, 3n^2-n-20000
    pent_low = solve_quadratic(3,-1,-2000)
    pent_high = solve_quadratic(3,-1,-20000)
    pentagons = [int(n*(3*n-1)/2) for n in range(int(pent_low[0]+1),int(pent_high[0]))]
    candidates.append(pentagons)
    # hex: n(2n−1), 2n^2-n-1000, 2n^2-n-10000
    hex_low = solve_quadratic(2,-1,-1000)
    hex_high = solve_quadratic(2,-1,-10000)
    hexagons = [int(n*(2*n-1)) for n in range(int(hex_low[0]+1),int(hex_high[0]))]
    candidates.append(hexagons)
    # hept: n(5n−3)/2 5n^2-3n-2000, 5n^2-3n-20000
    hept_low = solve_quadratic(5,-3,-2000)
    hept_high = solve_quadratic(5,-3,-20000)
    heptagons = [int(n*(5*n-3)/2) for n in range(int(hept_low[0]+1),int(hept_high[0]))]
    candidates.append(heptagons)
    # oct: n(3n−2), 3n^2-2n-1000, 3n^2-2n-10000
    oct_low = solve_quadratic(3,-2,-1000)
    oct_high = solve_quadratic(3,-2,-10000)
    octagons = [int(n*(3*n-2)) for n in range(int(oct_low[0]+1),int(oct_high[0]))]
    candidates.append(octagons)
    return candidates

def get_valid_cyclics(prev, candidate_polygons):
    last_two = prev % 100
    cyclics = [i for i in candidate_polygons if (i-i%100)/100 == last_two]
    return cyclics     

# at each step try to add one more candidate to used
# making sure you have valid cyclic values
def find_solution_rec(candidates, used_indeces, used_candidates, solution):
    if len(solution) == len(candidates):
        # check last value cycles with first
        last_two = solution[-1] % 100
        first_two = solution[0]//100
        if last_two == first_two:
            return solution
        else:
            return None
    else:    
        for i in [j for j in range(len(candidates)) if j not in used_indeces]:
            candidate_polygons = candidates[i]
            valid_cyclics = get_valid_cyclics(solution[-1], candidate_polygons)
            if len(valid_cyclics) > 0:
                used_indeces.append(i)
                used_candidates.append(valid_cyclics)            
                for polygon_value in used_candidates[-1]:
                    solution.append(polygon_value)
                    inner_solution = find_solution_rec(candidates, used_indeces, used_candidates, solution)    
                    if inner_solution is None:    
                        solution.pop()
                    else:
                        return inner_solution
                used_indeces.pop()
                used_candidates.pop()     

def find_solution(candidates):
    used_indeces = [0]
    used_candidates = [candidates[0]]
    solution = []
    for polygon_value in used_candidates[-1]:
        solution.append(polygon_value)
        inner_solution = find_solution_rec(candidates, used_indeces, used_candidates, solution)    
        if inner_solution is None:    
            solution.pop()
        else:
            return inner_solution

candidates = get_candidates()

# since each polygon candidate is present in solution, and solution is cyclic, we can pick triangles to be the first

solution = find_solution(candidates)
print(sum(solution))

